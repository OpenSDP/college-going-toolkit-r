---
title: "SDP Data Linking Tasks"
author: "Strategic Data Project"
date: "November 16, 2016"
output: 
  html_document: 
    toc: yes
---

```{r, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, comment=NA}
# Set options for knitr
library(knitr)
knitr::opts_chunk$set(comment=NA, warning=FALSE, 
                      error=FALSE, message=FALSE, fig.align='center')
options(width=120)
library(dplyr)
library(magrittr)
```

# SDP Data Linking Tasks



## Task 1: Prior Achievement

### Purpose

Prepare 8th grade test scores for the analysis file.

### Files needed

Prior_Achievement output file from Task 5 in **Clean**

**After this step** you will have a temporary file `tests` that contains 
prior achievement information for math, ELA, and math-ELA composite score.

#### 1.1 Load the File and Check Uniqueness

Begin Step 1 of Connect by loading the Prior_Achievement file resulting from 
Task 5. 


```{r echo=TRUE}
# Read in Stata
library(haven) # required for .dta files

# To read data from a zip file we create a connection to the path of the 
# zip file
tmpfileName <- "clean/Prior_Achievement.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
stuach <- read_stata(con) # read data in the data subdirectory
```


Note the structure of the file. Thanks to Task 5, the file is unique by sid 
(highlighted in blue) and contains test scores for only 8th grade math , ELA and 
math-ELA composite. If your data is not structured like this, please review 
Task 5.

Raw scores (math_raw_score and ela_raw_score from Task 5) are not shown. You 
will primarily use scaled or standardized scores in future analyses. However, 
keep raw scores in your file to compare results between scaled, standardized, 
or raw scores later on.

#### 1.2 Rename variables to indicate that thyey are 8th grade scores

```{r echo=TRUE}
stuach %<>% rename( 
       test_math_8_raw = raw_score_math,
       test_ela_8_raw = raw_score_ela,
       test_math_8 = scaled_score_math,
       test_ela_8 = scaled_score_ela,
       test_composite_8 = scaled_score_composite,
       test_math_8_std = scaled_math_std,
       test_ela_8_std = scaled_ela_std, 
       test_composite_8_std = scaled_score_composite_std)
```

#### 1.3 Define Prior Achievement Quartiles in Each Subject

Prior achievement quartiles have to be created by subject and by year. 

To create a variable to capture the quartile of an eighth grader’s score in 
each subject, relative to peers who took the same test, the same school year.

This allows you to compare performance of each student to peers in the same year.

In R this can be done simply combining a `group_by` and `mutate` command.

```{r echo=TRUE}
stuach %<>% group_by(school_year) %>% 
  mutate(qrt_8_math = ntile(test_math_8, 4), 
         qrt_8_ela = ntile(test_ela_8, 4), 
         qrt_8_composite = ntile(test_composite_8, 4))
```


### Step 2: School Crosswalk

Purpose: Prepare a crosswalk* between school codes and names. This allows you to link a high
school students’ high school graduation with their college enrollment outcomes.
Files needed: School research file from Identify
After this step you will have created a temporary file `highschoolinfo' that contains a crosswalk
between school codes and school names.

#### Load the File and Check Uniqueness

```{r echo=TRUE}
# To read data from a zip file we create a connection to the path of the 
# zip file
tmpfileName <- "clean/School.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
schl <- read_stata(con) # read data in the data subdirectory
```


Load the School research file from Identify. Restrict the 'universe' of schools to only
include high schools.


A crosswalk table ensures the final file is unique by school_code and that one 
school_code maps to one school_name. For example, in an uncleaned file, Albert 
Einstein High School might be spelled three ways, "A. Einstein HS," 
"Einstein High School," or "A.E. HS," but have one school_code. Alternatively, 
"Jones High School" might have a code of 153 and 154. You must fix these issues 
before moving on.

```{r echo=TRUE}
# keep only the school code and school name
schl <- select(schl, school_name, school_code)
# keep school_code school_name
# duplicates drop
schl <- distinct(schl)
# // check that the file is unique by school_code
# isid school_code
length(unique(schl$school_code)) == nrow(schl)

```

#### Generate First, Last, and Longest High School Variables

Next, generate three variables, `first_hs_code`, `last_hs_code`, and 
`longest_hs_code`. Set them equal to the `school_code` of each high school.

```{r}
# // creates first / last / longest hs id variables
schl$first_hs_code <- schl$school_code
schl$last_hs_code <- schl$school_code
schl$longest_hs_code <- schl$school_code
```


### Step 3: Student Attributes

**Purpose:** Load Student Attributes data to obtain time-invariant information for 
students in the system.
**Files needed:** `Student_Attributes` output file from Task 1 in Clean

**After this step** you will have loaded the Student Attributes data into memory.


#### Load the File and Check Uniqueness

```{r echo=TRUE}
# To read data from a zip file we create a connection to the path of the 
# zip file
tmpfileName <- "clean/Student_Attributes.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
stuatt <- read_stata(con) # read data in the data subdirectory
```



### Step 4: Student School Year

**Purpose:** Merge Student School Year data with Student Attributes data in memory and generate
program participation status variables.
**Files needed:** `Student_School_Year_Ninth` output file from Task 3 in Clean

**After this step** You will have merged Student School Year data with Student 
Attributes data into memory and generated variables that indicate if a student h
as ever been classified as FRPL (Free and Reduced Price Lunch), 
IEP (Individualized Education Plan), ELL(Engish Language Learner) or Gifted
in the system or during high school.


#### Merge on Student School Year

Merge the Student School Year file with the Student Attributes
file in memory. This adds student-level information that may
change from year to year (i.e FRPL,IEP, ELL or Gifted). This is a
1:m (one-to-many) merge because the Student Attributes file is
unique by sid and the Student School Year file is unique by sid +
school_year.


```{r echo=TRUE}
tmpfileName <- "clean/Student_School_Year_Ninth.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
stusy <- read_stata(con)
stusy <- inner_join(stusy, stuatt, by = "sid")

```


Before conducting the merge, the Student School Year output file should be unique by sid and school_year and
contain information on all available grades. The Student School Year data should also include the first_9th_
school_year_observed variable.

#### Checking the Merge

In an ideal world records match perfectly. However, administrative records are often messy. Perfect merges
rarely occur. Therefore, consider a merge satisfactory if at least 95% of students appear in both files.
The results of the merge can be checked by running a tabulation of the _merge variable. The _merge variable
is automatically created when data files are merged.
Keep only students at the intersection of the two files.


```{r echo=TRUE}
# // check the number and percentage of students appearing in both files

stusy <- arrange(stusy, sid)
length(unique(stusy$sid)) == length(unique(stuatt$sid))
```

#### Generate Program Participation Variables

Now, create binary variables (variables that assume values of 0 or 1) to 
indicate if a student ever:

1. qualified to participate in FRPL;
2. qualified for an IEP;
3. classified as ELL (or LEP);
4. qualified for gifted program.

These variables, (`frpl_ever`, `iep_ever`, `ell_ever`, and `gifted_ever`) allow 
you to explore high school and college outcomes for students that participated 
in these programs for one or more school years. 

Create analogous variables to capture students’ program participation status in 
high school.

```{r echo=TRUE}
# In R this is an easy way to go by just using group_by and mutate
tmp <- filter(stusy, (grade_level >= 9 & grade_level <= 12)) %>% 
               group_by(sid) %>% 
  summarize(frpl_ever_hs = ifelse(max(frpl) > 0, 1, 0), 
         iep_ever_hs = max(iep), 
         ell_ever_hs = max(ell), 
         gifted_ever_hs = max(gifted))

stusy <- inner_join(stusy, tmp, by = "sid")
stusy <- arrange(stusy, sid)

stusy %<>% group_by(sid) %>% 
  mutate(frpl_ever = ifelse(max(frpl) > 0, 1, 0), 
         iep_ever = max(iep), 
         ell_ever = max(ell), 
         gifted_ever = max(gifted))

rm(tmp)
```

High school status variables (`frpl_ever_hs`, `iep_ever_hs`, `ell_ever_hs` 
and `gifted_ever_hs`) allow flexibility in defining student subgroups. This is 
useful if participation data is missing non-randomly before a student enters 
high school, or if variables that capture participation are overly inclusive 
across years. For example, a student who demonstrates limited English 
proficiency in 4th grade may be fluent in English by 9th grade. It may or may 
not be appropriate to categorize the student as ELL in analyses that examine 
high school outcomes.


### STEP 5: Student School Enrollment

**Purpose:** Merge Student School Enrollment with data in memory.

**Files needed:** Student_School_Enrollment_Clean output from Task 4 in Clean

**After this step** you will have merged Student School Enrollment data with 
data in memory.


#### Merge on Student School Enrollment


Merge the Student School Enrollment file onto the analysis file.
This allows you to identify high schools students enrolled at
different times.

This is a 1:m merge, as the data file from the previous two
steps is unique by sid + school_year and the Student School
Enrollment file is unique by sid, school_year, school_code, and
enrollment_date.

```{r echo=TRUE}
tmpfileName <- "clean/Student_School_Enrollment_Clean.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
stuschl <- read_stata(con)

stusy <- inner_join(stusy, stuschl, by = c("sid", "school_year"))
```

Before the merge, the Student School Enrollment file should
be unique by sid, school_year, school_code, and enrollment_
date.

#### Checking the Merge

```
// check the number and percentage of students appearing in both files
sort sid
tab _merge if sid!=sid[_n-1]
// once you have checked the _merge, keep only students at the intersection of both files
keep if _merge==3
drop _merge
```

### STEP 6: High School Indicators and Outcomes

Purpose: Generate high school indicators and outcomes in two categories.
Files needed: The file in memory from Steps 3-5 and `highschoolinfo' from Step 2
After this step you will have created a number of high school indicators and 
outcomes: 1) first, last, and longest high school; 2) 9th grade and graduation 
cohorts; and 3) end of high school outcomes: ontime and late graduates and high 
school enrollment outcomes for non-graduates.


#### 6.1 Define First, Last, and Longest High School


To begin, make sure that the data includes only student observations in high 
school. (You have done this in Clean already; we are checking it again here).

```{r echo=TRUE}
stusy %<>% filter(grade_level >= 9 & !is.na(grade_level) & 
                    grade_level <= 12)

# TODO: Why is grade level > 12 sometimes?
```

There might be students who are assigned to high schools but whose attendance 
duration is 0. Drop these school assignments to ensure that you assign students 
to high schools they actually attended. 

```{r echo=TRUE}
stusy %<>% filter(days_enrolled > 0)
```

#### Define First High School

To identify a student’s first high school, determine the first enrollment 
episode for the student.

In some cases, students enroll in more than one school at the same time. In such 
cases, assign them to the school where they attended longest.

Should students have multiple first enrollments of the same length, randomly 
assign them to one of these schools.

```{r echo=TRUE}

stusy %<>% arrange(sid, school_year, enrollment_date, desc(days_enrolled))

stusy %<>% group_by(sid) %>%
  arrange(sid, school_year, enrollment_date, desc(days_enrolled)) %>% 
  mutate(first_hs_code = first(school_code), 
         last_hs_code = last(school_code))

```


#### Define Last High School


To identify a student’s last high school, determine the last enrollment episode for the student.
In cases of joint enrollment, use the school where the student attended longest.
Where joint enrollment duration is the same, randomly assign the last high school.


#### Define Longest High School

To determine the longest enrolling HS, you first have to add up all enrollments 
within a HS. Since in Clean you ensured that there are no overlapping enrollments 
within a school, you can add enrollments up. 

In cases where students enrolled in more than one school for the same amount of 
time, randomly assign the longest high school


```{r}
# egen total_days_enrolled_in_school = sum(days_enrolled), by(sid school_code)
# gsort sid -total_days_enrolled_in_school
# bys sid: gen temp_longest_hs_code = school_code if _n==1
# egen longest_hs_code = max(temp_longest_hs_code), by(sid)

stusy %<>% group_by(sid, school_code) %>% 
  mutate(total_days_enrolled_in_school = sum(days_enrolled))

stusy %<>% group_by(sid) %>% 
  mutate(total_days_enrolled_in_school_max = max(total_days_enrolled_in_school))

stusy %>% select(sid, school_code, enrollment_date, total_days_enrolled_in_school, 
                 days_enrolled, first_hs_code) %>% 
  head

stusy %<>% group_by(sid) %>% 
  mutate(longest_hs_code = unique(school_code[total_days_enrolled_in_school_max == total_days_enrolled_in_school])[1])


stusy %>% select(sid, school_code, enrollment_date, total_days_enrolled_in_school, 
                 days_enrolled, first_hs_code, longest_hs_code) %>% 
  head

# Drop temporary variables
stusy$total_day_enrolled_in_school <- NULL
stusy$total_days_enrolled_in_school <- NULL
stusy$total_days_enrolled_in_school_max <- NULL

```


#### Merge on highschoolinfo

Merge the `highschoolinfo’ tempfile created in Step 2 onto the
current file. This allows you to obtain school names( first_hs_
name and last_hs_name) associated with the high school codes
just captured.


This requires merging data currently loaded in Stata to the
`highschoolinfo' tempfile three times – once on first_hs_code,
then on last_hs_code, and finally on longest_hs_code. These
merges will all be m:1 (many to one) because the file in memory
contains multiple observations per school and the tempfile
contains only one per school.

```{r echo=TRUE}

stusy <- left_join(stusy, schl[, c("school_name", "first_hs_code")], 
                   by = c("first_hs_code"))

stusy %<>% rename(school_name_first_hs = school_name)

stusy <- left_join(stusy, schl[, c("school_name", "last_hs_code")], 
                   by = c("last_hs_code"))

stusy %<>% rename(school_name_last_hs = school_name)

stusy <- left_join(stusy, schl[, c("school_name", "longest_hs_code")], 
                   by = c("longest_hs_code"))

stusy %<>% rename(school_name_longest_hs = school_name)


```

By specifying gen(_m`type’), you can
keep all three merge variables in the dataset, and verify the
return of each merge.


After each merge drop observations that do not show up in the enrollment data, as well as observations
for which you cannot assign high school names (students who have school_codes not listed in the
`highschoolinfo' file). Also, drop students that had neither a first nor last high school defined. These
restrictions should eliminate very few students from the analysis file.


#### 6.2 Assign Ninth Grade and Graduation Cohorts

Assigning students to cohorts will allow you to calculate various indicators 
(e.g. high school graduation, college enrollment) using a different set of 
students in the denominator. For example, when calculating college enrollment, 
you could use the ninth grade cohort to illustrate how high schools prepared 
their incoming freshmen for future success, or you could use the graduating 
cohort to illustrate the percentage of a high school’s graduates enrolling in 
college.

Since the ninth grade cohort is equal to first_9th_school_year_observed in the 
student attributes file, just rename first_9th_school_year_observed to chrt_ninth.

```{r echo=TRUE}
#// define ninth grade cohort
#rename first_9th_school_year_observed chrt_ninth

stusy %<>% rename(chrt_ninth = first_9th_school_year_observed)

```


The graduation cohort variable, chrt_grad, is the school year in which a student 
graduated. If a student obtained a diploma prior to September 1st, the chrt_grad 
variable is the same as the year of hs_diploma_date. If a student received a 
diploma between September 1st and December 31st treat them as graduates for the 
next school year.

```{r echo=TRUE}
# // define graduation cohort
stusy$chrt_grad <- NULL

library(lubridate)

head(year(stusy$hs_diploma_date))
head(month(stusy$hs_diploma_date))

stusy$chrt_grad <- ifelse(month(stusy$hs_diploma_date) < 9, year(stusy$hs_diploma_date), 
                          year(stusy$hs_diploma_date) + 1)
```

**Question 6.2** Test your understanding by filling the shaded areas below.

```{r}

stusy %>% filter(sid %in% c(16305, 16306, 16307)) %>% 
  select(sid, hs_diploma_date, chrt_ninth, chrt_grad) %>% 
  distinct(.keep_all=TRUE) 


```

Note, that in Clean, you assigned every student a first_ninth_school_year_observed. 
You either had their first night grade in the data, or if they transferred into 
the district later in high school, you backward mapped them to an appropriate 
ninth grade school year. Thus, chrt_ninth should never be missing. Chrt_grad, 
however, could be missing, because not all students graduated, thus they will 
not be assigned a graduating cohort. 

#### 6.3 Define High School Outcomes

To determine end of high school outcomes, you need a student's last withdrawal 
code (withdrawal code at their last high school). Use the last withdrawal code 
to determine if the student graduated, transferred out, dropped out, or has 
another outcome. 

#### 6.3a Group last withdrawal codes together into four end of high school outcomes:

1 = Graduated (define graduated using withdrawal data and hs_diploma in the 
Student Attributes file, or any other source of graduation information used)
2 = Transfer Out
3 = Drop Out
4 = Other (all other reasons for withdrawal)

Outcomes are captured using the last_wd_group variable. Assigning the last 
withdrawal code to last_wd_group requires an understanding of decision rules in 
your agency. Some withdrawal codes may be ambiguous or redundant and need to be 
combined to fit under the four categories. Therefore, it is important to elicit 
help from those knowledgeable of local graduation, transfer, and dropout policies 
in your agency. For example, there may be special codes for students who are 
incarcerated or pass away that are not well-documented. We provide an example 
below, but you will have to customize this script based on values your agency 
uses. Particularly, for dropouts you should make sure the agency is not being 
penalized for something it does not have control over.

First, examine the values for last_withdrawal_reason. You will have to make sure 
that you capture all these values in defining the last withdrawal groups. Should 
your data have any missing values for last_withdrawal_reason, be sure to assign 
those to an appropriate category. In some agencies, a missing withdrawal code 
indicates that the student is still enrolled, so assign them as still enrolled.

```{r echo=TRUE}
stusy %>% arrange(sid) %>% 
  summarize(last_withdrawal = last(last_withdrawal_reason)) %>% 
  select(last_withdrawal) %>% unlist %>% table

```



```{r echo=TRUE}
stusy$last_wd_group <- NA
stusy$last_wd_group[stusy$last_withdrawal_reason %in% c("Home School", 
                                                        "Other Transfer", 
                                                        "Transfer Out of District", 
                                                        "Death")] <- 2
stusy$last_wd_group[stusy$last_withdrawal_reason %in% c("Absenteeism", 
                                                        "No Show", 
                                                        "Expulsion")] <- 3
stusy$last_wd_group[stusy$hs_diploma == 1] <- 1
stusy$last_wd_group[is.na(stusy$last_wd_group)] <- 4
table(is.na(stusy$last_wd_group))
```

Note that we populated the graduating group last; this is because the evidence 
of a high school diploma overrides any other value for last withdrawal reason. 
Any remaining last_withdrawal_reason values were then classified as 4, Other. 

#### 6.3b Define High School Outcomes

Identify On-Time and Late High School Graduates

First, identify students who graduated within 4 years of entering high school 
(on-time graduates) as well as students who took more than 4 years 
(late graduates). These variables allow you to examine time taken to complete 
high school and explore how this varies across high schools within a system. 
These two variables have to add up to the total graduates.

```{r echo=TRUE}
# // define on-time graduates

stusy$ontime_grad <- ifelse(stusy$chrt_ninth >= stusy$chrt_grad -3 & 
                        !is.na(stusy$chrt_ninth) & 
                        !is.na(stusy$chrt_grad) & 
                        stusy$hs_diploma == 1 , 1, 0)

# // define late graduates
stusy$late_grad <- ifelse(stusy$ontime_grad == 0 & 
                        !is.na(stusy$chrt_ninth) & 
                        !is.na(stusy$chrt_grad) & 
                        stusy$hs_diploma == 1 , 1, 0)
all(stusy$late_grad + stusy$ontime_grad == stusy$hs_diploma)
```

Identifying High School Enrollment Outcomes for Non-Graduates

Next, assign high school enrollment outcomes for students who have not graduated 
by a point in time. You may define this point, but typically it is the current 
year if data is up to date. It is important that each student is either marked 
as a graduate or assigned to only one of the following categories. Notice how 
the definition of each category is conditional on all previous categories.

```{r}
# // still enrolled

maxDataYear <- max(stusy$school_year)
stusy %<>% group_by(sid) %>% 
  mutate(still_enrl = ifelse(max(school_year) == maxDataYear & 
                               hs_diploma != 1, 1, 0))
# // transfer out

stusy$transferout <- ifelse(stusy$last_wd_group == 2 & 
                              stusy$hs_diploma!=1 & 
                              stusy$still_enrl != 1, 1, 0)
# // drop out
stusy$dropout <- ifelse(stusy$last_wd_group == 3 & 
                              stusy$hs_diploma!=1 & 
                              stusy$still_enrl != 1 & 
                              stusy$transferout != 1, 1, 0)
# // disappear
stusy$disappear <- ifelse(stusy$dropout != 1 & 
                              stusy$hs_diploma!=1 & 
                              stusy$still_enrl != 1 & 
                              stusy$transferout != 1, 1, 0)

```

You have generated most of the key high school indicators and outcomes, so you 
no longer need all source variables. Keep only the variables listed here.

Based on these time-invariant variables, the file is now unique by sid. To drop 
other variables, first keep the 30 then drop duplicates.

```{r}
# // keep time-invariant variables
stusy %<>% ungroup %>% 
  select(sid, male, race_ethnicity, 
         last_wd_group, still_enrl, transferout, 
         dropout, disappear,
         matches("hs_diploma|_ever|_hs_code|school_name|chrt|_grad"))

stusy %<>% distinct(.keep_all = TRUE)

# // make sure the file is unique by sid
nrow(stusy) == length(unique(stusy$sid))

```

### STEP 7: Prior Achievement Part 2

Purpose: Merge prior achievement test scores onto the analysis file.
Files needed: the analysis file in memory from Step 6 and `tests' from Step 1
After this step you will have merged prior achievement data with the current analysis file.

#### Merge on tests

You have a data set unique by sid that contains key student
attributes, high school indicators and outcomes. All you need
now are 8th grade test scores.
To add prior achievement scores to the file, merge the `tests'
tempfile from Step 1 onto the current analysis file. This is a 1:1
merge on sid.

```{r echo=TRUE}
stusy <- left_join(stusy, stuach, by = "sid")
```


Next, drop students who do not appear in the analysis file but
have 8th grade test scores. You may expect to capture prior
achievement for most students, but not all students will have
score information. For example, students who first enroll in the
system during high school (after 8th grade) or were exempt from
tests will not have prior test scores.

Review the merge results, to see what percentage of students
have prior scores.

```{r echo=TRUE}
table(is.na(stusy$qrt_8_math))
```


In this case, almost 70% of high school students have prior
achievement data. 

### STEP 8: Examining the Analysis File Part 1

Congratulations! You now finished working with agency administrative records and can save a preliminary
analysis file to generate analyses on student transitions through high school completion and college going
success. First, order the variables in a sensible way.

```{r}
stusy %<>% select(sid, male, race_ethnicity, hs_diploma, hs_diploma_type, 
                  hs_diploma_date, frpl_ever, iep_ever, ell_ever, gifted_ever,
                  frpl_ever_hs, iep_ever_hs, ell_ever_hs, gifted_ever_hs,
                  first_hs_code, last_hs_code, longest_hs_code, school_name_first_hs, 
                  school_name_last_hs, school_name_longest_hs, last_wd_group, chrt_ninth, 
                  chrt_grad, ontime_grad, late_grad, still_enrl, transferout,
                  dropout, disappear, test_math_8_raw, test_math_8, 
                  test_math_8_std, test_ela_8_raw, test_ela_8, 
                  test_ela_8_std, test_composite_8, test_composite_8_std, 
                  qrt_8_math, qrt_8_ela, qrt_8_composite)
```



All that is left to do is process college enrollment records from the National 
Student Cleainghouse (NSC), and merge these data onto the Student_CollegeGoing 
file. This creates a single analysis file to generate analyses on student 
transitions through high school and college.

Before moving on, take a moment to admire your work and refamiliarize yourself 
with sources and processes for each of these variables. Ask yourself: What
research files were the variables produced from? How were high school indicators 
and outcomes created?

```{r}
names(stusy)
```


Use the following questions for the numbered variables above to guide your thoughts:
1. (1-6): Which research file are these variables from?
2. (7-14): Which research file are these variables from?
3. (15-17): How are first, last, and longest high school codes identified?
4. (18-20): From what research file are first, last, and longest high school names obtained?
5. (21): What does the last_wd_group variable describe?
6. (22-23): How are 9th grade and graduation cohorts defined?
7. (24-29): How are graduation and high school enrollment outcomes defined?
8. (30-40): Which research file are these variables from?

### STEP 9: National Student Clearinghouse Data

Purpose: Generate college enrollment and persistence indicators

Files needed: The Student_NSC_Enrollment_Indicators data from Task 7 in Clean, 
and the Student_CollegeGoing file you saved in Step 8.

After this step you have created the indicators that will be used for college 
going analysis.

For all NSC related analyses, we create two types of indicators: one bases on 
the graduating cohort, and another based on the ninth grade cohort. Each of these 
indicators serves a different purpose, and can be used to answer different 
questions. For example, if you are interested in how high schools or the entire 
agency is doing in enrolling their graduates to college, you would be using the 
indicators based on the graduating cohort. 

If, however, you want to evaluate how the high schools or agency is preparing 
their incoming freshman to go through high school and enroll in college, you 
will use the indicators bases on the night grade cohort. In addition, we create 
separate indicators to evaluate how soon after high school students enroll in 
college. One set of indicators is based on enrollment on October 1st. The second 
set of indicators is based on enrollment within two years of graduation. This 
latter indicator is calculated based on the calendar date of the student’s high 
school graduation (or, in case of the ninth grade cohort, the expected on-time 
high school graduation). 

To begin this step, open the Student_NSC_Enrollment_Indicators file from Task 7, 
and merge the Student_CollegeGoing file you saved in Step 8.

```{r echo=TRUE}
tmpfileName <- "clean/Student_NSC_Enrollment_Indicators.dta"
con <- unz(description = "data/clean.zip", filename = tmpfileName, 
           open = "rb")
stunsc <- read_stata(con)

# // merge on variables needed from Student_College_Going
tmp <- select(stusy, sid, hs_diploma_date, hs_diploma, chrt_grad, chrt_ninth)
# Use inner_join to only keep students in both
stunsc <- inner_join(tmp, stunsc, by = c("sid")); rm(tmp)
```

#### 9.1 Create a varaible to indicate if the student enrolled in college within two years of graduating from high school.


Start with the graduating cohort. If the student enrolled in college within 2*365 days after high school
graduation, set the indicator to 1.


```{r}
# // create and indicator to show if the student enrolled within two years of HS graduation

stunsc$enrl_ever_w2_grad <- ifelse(stunsc$first_enrl_date_any < 
                                     (stunsc$hs_diploma_date + (365*2)) &
                                     !is.na(stunsc$hs_diploma_date) & 
                                     !is.na(stunsc$first_enrl_date_any), 
                                   1, 0)
```

For the ninth grade cohort, first create a variable that represents on-time graduation. Set this date to
September 1st the fourth year after the student’s ninth grade cohort. Then create the enrollment indicator
using this date.

```{r}
stunsc$ontime_yr <- stunsc$chrt_ninth + 3
stunsc$ontime_date <- mdy(paste0("09", "01", stunsc$ontime_yr))
# // create and indicator to show if the student enrolled within two years of expected HS graduation
stunsc$enrl_ever_w2_ninth <- ifelse(stunsc$first_enrl_date_any < (stunsc$ontime_date + (365*2)) & 
                                      !is.na(stunsc$ontime_date) & !is.na(stunsc$first_enrl_date_any), 
                                    1, 0)

```

Question 9.1 Test your understanding by filling the shaded areas below.

```{r}
stunsc %>% filter(sid %in% c(15647,15656,15658)) %>% 
  select(sid, chrt_ninth, chrt_grad, hs_diploma_date, first_enrl_date_any, 
         enrl_ever_w2_grad, ontime_yr, ontime_date, enrl_ever_w2_ninth) %>% 
  distinct(.keep_all=TRUE) %>% 
  as.data.frame
```


#### 9.2 Create variables to indicate if the student was enrolled in college by Oct 1


This variable indicates if a student enrolled in college immediately after high 
school. In addition, we use indicators based on October 1st college enrollment 
to track if student persisted in college. For this, we need to create variables 
to indicate enrollment on October 1st the 1st, 2nd, 3rd and 4th year after high 
school graduation.

First, create placeholder variables for both the ninth and graduating cohort, 
for each of the four years. 

```{r}
# // Create the 4 enrollment outcomes of interest by October 1st
# foreach num of numlist 1/4 {
# gen enrl_1oct_grad_yr`num' = .
# gen enrl_1oct_ninth_yr`num' = .
# }
```

Now, loop through these year values. We replace the above created placeholder 
variables with 1 if the student enrolled in college as of October 1st and the 
student's enrollment for that year ended after October 1st. We do this for the 
1st, 2nd, 3rd and 4th year after high school graduation. As we loop through the 
variables, we have to make sure that we are only replacing values for students 
who graduated in the year in the current loop, so we have to set a condition 
that ensures that the record is for a student whose diploma date falls in that 
school year.

```{r}

stunsc$n_enroll_begin_date[stunsc$sid == 16011]

stunsc %>% filter(sid %in% c(16011, 16016)) %>% 
  select(sid, chrt_grad, hs_diploma_date, first_enrl_date_any, n_enroll_begin_date)

testDF <- stunsc %>% 
  mutate(compDateG = ymd(paste0(chrt_grad, "-10-01")), 
         compDateE = ymd(paste0(chrt_ninth, "-10-01")),
         compInterval = n_enroll_begin_date %--% n_enroll_end_date) %>%
    mutate(enrl_1oct_grad_yr1 = compDateG %within% compInterval, 
           enrl_1oct_grad_yr2 = (compDateG + 365) %within% compInterval,
           enrl_1oct_grad_yr3 = (compDateG + 730) %within% compInterval,
           enrl_1oct_grad_yr4 = (compDateG + 1095) %within% compInterval) %>% 
  mutate(enrl_1oct_grad_yr1 = ifelse(compDateE %within% compInterval, 1,
                                     as.numeric(enrl_1oct_grad_yr1)),
           enrl_1oct_grad_yr2 = ifelse((compDateE + 365) %within% compInterval, 1, 
                                       as.numeric(enrl_1oct_grad_yr2)),
           enrl_1oct_grad_yr3 = ifelse((compDateE + 730) %within% compInterval, 1, 
                                       as.numeric(enrl_1oct_grad_yr3)),
           enrl_1oct_grad_yr4 = ifelse((compDateE + 1095) %within% compInterval, 1, 
         as.numeric(enrl_1oct_grad_yr4)))
  
testDF %>% filter(sid %in% c(16011, 16016)) %>% 
  select(sid, chrt_grad, hs_diploma_date, first_enrl_date_any, n_enroll_begin_date, 
         n_enroll_end_date,
         enrl_1oct_grad_yr1, enrl_1oct_grad_yr2, enrl_1oct_grad_yr3, enrl_1oct_grad_yr4) %>% as.data.frame

# // loop through the graduation years (actual and expected) that exist in your data.
# // actual
# levelsof chrt_grad, local(chrt_grad_values)
# foreach yr of local chrt_grad_values {
# // assign the outcome of interest to assume a value of 1 when students enroll on or
# before October 1st
# local yr1 = `yr'
# local yr2 = `yr' + 1
# local yr3 = `yr' + 2
# local yr4 = `yr' + 3
# local yr5 = `yr' + 4
# foreach num of numlist 1/5 {
# replace enrl_1oct_grad_yr`num' = 1 if (n_enroll_begin_date <=
# td(1oct`yr`num'')) & (td(1oct`yr`num'') <= n_enroll_end_date) & ((year(hs_diploma_date) ==
# (`yr') & month(hs_diploma_date) <=9) | ((year(hs_diploma_date) == `yr'-1 & month(hs_diploma_
# date)>9)))
# }
# }
# // expected
# levelsof ontime_yr, local(chrt_ninth_values)
# foreach yr of local chrt_ninth_values {
# //assign the outcome of interest to assume a value of 1 when students enroll on or
# before October 1st
# local yr1 = `yr'
# local yr2 = `yr' + 1
# local yr3 = `yr' + 2
# local yr4 = `yr' + 3
# local yr5 = `yr' + 4
# foreach num of numlist 1/5 {
# replace enrl_1oct_ninth_yr`num' = 1 if (n_enroll_begin_date <=
# td(1oct`yr`num'')) & (td(1oct`yr`num'') <= n_enroll_end_date) & chrt_ninth == (`yr' - 3)
# }
# }
```

