---
title: "SDP R Glossary"
author: "Strategic Data Project"
date: "November 28, 2016"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting up your R Environment

It is highly recommended that you use the RStudio IDE to interact with R. RStudio 
is a free and open source IDE that is available on all computing platforms. 
RStudio provides a number of features that make working with R more convenient. 

## Getting Help

In R you can get help at any time by simply typing `?` and the command of 
of interest. For example `? summary` will open up the help page for the 
summary function.

If you are not sure of the exact name of a function you can use `??` to search 
through the help files available in your R installation. For example `?? model` 
will search for all files that reference the term model. 

## Inserting Comments

In R the `#` character is used to denote a comment. It is useful to insert 
frequent comments that describe what your code is doing. 

Anything the follows a `#` character will be ignored by R until the next 
linebreak. To make a block of comments use the following:

```
# Commenting one line

### Starting a block of comments
### The spacing makes it clear
### Being consistent is key

```

## Breaking Up Long Lines of Code

If a code is long, it can be practical to break it into multiple lines. 
In R there is no need to specifically tell R that code continues on the 
next line. If you use the RStudio IDE it will assist you in making appropriate 
linebreaks. 

## Quotes

R recognizes both `'single'` and `"double"` quotes. At times it may also be 
necessary to use both types of quotes together, such as when passing a string 
that contains a command that operates on a string. 

```
eval(parse(text=("summary(mtcars['Valiant', ])")))
```

# 1. Data Management

## 1.1 Handling Datasets

Working directories are the number one source of confusion for new R users. 
If you use RStudio and RStudio Projects you can eliminate a lot of confusion 
and hassle with setting and changing working directories. 

To view and set th working directory use:

`getwd()` to view the current working directory
`setwd("C:\MyProject")` to set the working directory to "MyProject"

To remove an object from the R workspace:

`rm(object)` 

R can read a variety of data files. R can store files in a native file format 
using either the `.rda` or `.RData` extension. To use files of this type: 

`load('mydata.rda')`

To read in data in other formats you will likely want an external library. For 
data from other statistical software, the `haven` package is excellent at 
reading and writing these files and has the greatest compatibility. 

```
library(haven)
mydata <- read_stata(file = "MyStataFile.dta") 
```

For tabular data the `readr` package is fast and easy to use. 

```
library(readr)
mydata <- read_csv(file = "MyCSVfile.csv")
```

Note that when reading in data you must tell R what name you will assign this 
data in the workspace. This is because R allows you to read in multiple data 
files simultaneously unlike many other common statistical software packages. Try 
to use a short and meaningful name for your data.

R can read Excel files directly through a variety of packages (readxlr, readxls), 
but if possible it is usually preferred to use Excel to convert these to CSV first.

You can also load data directly from a remote data source. R can connect to 
many external data stores directly. ODBC connections are very common. To connect 
to an ODBC connection

```
library(RODBC)

```

Combining datasets in R is easy. You can load multiple datasets into the workspace 
simultaneously and combine them in a variety of ways using common values between 
them. 

The simplest syntax for merging comes from the `dplyr` package which uses a 
command structure similar to SQL. 

- `inner_join` does a 1 to 1 merge 
- `full_join` does a many to many merge
- `left_join` does a one to many merge
- `right_join` does a many to one merge

## 1.2 Structuring Datasets

Collapsing data in R is achieved best by using the `group_by` and `summarize` 
commands in the `dplyr` package. This requires being explicit about how you 
want to summarize each field from many observations into one. 

```
library(dplyr)

collapsedData <- longData %>% group_by(idvar) %>% 
  summarize(meanCount = mean(count))
  
```

Alternatively, if your variables can all be summarized by the same function 
you can do the following:

```
library(dplyr)

collapsedData <- longData %>% select(var1, var2, var3, var4, idvar) %>% 
  group_by(idvar) %>% 
  summarize_all(funs = "mean")

```

Any variables not specified will be dropped, but you can retain the original 
data and just create a new object, e.g. `collapsedData`, for your summarized 
data. 

*reshape*

Reshaping data in R can follow two main approaches. If you need to reshape an 
entire dataset, the base R `reshape` command is powerful and flexible. Read 
the documentation carefully. 

If you need to expand or contract a few variables by an identifier column, the 
`tidyr` package provides an easy to remember syntax and interface to quickly 
do this. 

### 2.1 Handling variables

In R there is an important distinction between variables contained within a 
`data.frame` and variables stored in the global environment. 

Variables stored in a `data.frame` are accessed by any of the following methods:

```

dataframe$variable
dataframe[, "variable"]
dataframe[, 1]

```

*drop* 

To drop variables we can do any of the following

```
dataframe$variable <- NULL
dataframe[, "variable"] <- NULL
dataframe <- dataframe[, -1]

# dplyr
library(dplyr); library(magrittr)
dataframe %<>% select(-variable)

```

*keep*

In R, there is no specific keep command. You can pass a numeric index of column 
positions, or pass column names to drop any variables you do not want. 

```

dataframe <- dataframe[, c(1, 2, 3, 4)]
dataframe <- dataframe[, c("variable1", "variable2", "variable3")]

```

Using `dplyr` and the `select` function there are a number of powerful ways 
to specify which variables you want to keep. 

```

dataframe %<>% select(starts_with("variable"))

```

*generate*

Variable creation in R is as simple as assigning a variable in a data.frame a 
value.

```
dataframe$newvariable <- NA

```

If you want to assign a created variable some value based on values of other 
variables in the data:

```
dataframe$newvariable <- NA
dataframe$newvariable[dataframe$var1 == 'condition1'] <- 1
dataframe$newvariable[dataframe$var1 == 'condition2'] <- 2

## Alternatively

dataframe$newvariable <- ifelse(dataframe$var1 == "condition1", 1, 2)

```

Generating new variables as functions of other variables is also simple:

```

dataframe$newvariable <- mean(dataframe$oldvar)
dataframe$newvariable <- sum(dataframe$oldvar)

```

Generating a new variable that is a function of multiple other variables is also 
simple

```

dataframe$newvariable <- dataframe$var1 + dataframe$var2
dataframe$newvariable <- dataframe$var1 / dataframe$var2

# Be careful of order of operations

dataframe$newvariable <- dataframe$var1^2 / (dataframe$var2 - dataframe$var3)


```

You can also generate an empty `data.frame` as well:

```
mydata <- data.frame(var1 = NA, var2 = NA)

```


*replace*

In R, replacing variables is as easy as overwriting them:

```

dataframe$oldvariable <- dataframe$newvariable


```

Of course, you need to drop the other variable still:

```

dataframe$newvariable <- NULL

```

*duplicates*

Dropping duplicates.

R comes with the built in `duplicated` function which returns a logical vector 
the same length as the number of rows, TRUE if the row is duplicated.

```
duplicated(iris)

# If you only want a summary
summary(duplicated(iris))

```

By default, `duplicated` checks for duplication across *all* columns in the 
data. To specify the columns of interest, just select the variables before 
the duplicated call

```

duplicated(iris[, 1:2])

```

To drop duplicated rows we can pass the results of the `duplicated` call as a 
row index to the `data.frame` itself:

```
iris <- iris[duplicated(iris), ]

```

This is a bit awkward, so another way to do it is:

```
library(dplyr)

iris %<>% distinct(.keep_all = TRUE)

```

### Variable types

In R there are four common variable types:

- numeric
- integer
- character
- factor

To test what type a variable is you use the `is.type` construction, or you can 
ask R to return the class of the variable directly:

```
is.numeric(dataframe$myvariable)
is.integer(dataframe$myvariable)
class(dataframe$myvariable)
```

To convert between types, you use the `as.type` construction, or you can 
set the class of the variable directly:

```
dataframe$myvariable <- as.numeric(dataframe$myvariable)
class(dataframe$myvariable) <- "numeric"

```

Note that the `as.type` functions are not particularly savvy. For example, 
`as.numeric("1,000,000")` will return `NA`. There are a number of packages that 
implement special parsers for dealing with these types of variables, for example, 
the `decomma` function in the `eeptools` package handles the above case.

## 2.2 Summarizing variables

R has convenient built in summaries for the base data types:

```
summary(dataframe$myvariable)
summary(dataframe)

```

These return a 5 number summary of numeric variables and other useful information. 

Another summary method that is helpful is the `str` command, which provides a 
look at the first values occurring in a data.frame or variable, as well as the 
attributes of the object.

```
str(dataframe$myvariable)
str(dataframe)

```



